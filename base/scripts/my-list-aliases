#!/bin/bash
# Function: my-list-aliases
# Purpose: List all available aliases with descriptions and sources
# Usage: my-list-aliases [--help] [--platform] [pattern]
# Platform: All
# Dependencies: grep, sort

my_list_aliases() {
    local show_help=false
    local show_platform=false
    local pattern=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help=true
                shift
                ;;
            -p|--platform)
                show_platform=true
                shift
                ;;
            *)
                pattern="$1"
                shift
                ;;
        esac
    done
    
    if [[ "$show_help" == true ]]; then
        cat << EOF
Usage: my-list-aliases [OPTIONS] [PATTERN]

List all available aliases with descriptions and sources.

OPTIONS:
    -h, --help      Show this help message
    -p, --platform  Show only platform-specific aliases
    PATTERN         Filter aliases matching pattern (grep-style)

EXAMPLES:
    my-list-aliases                 # List all aliases
    my-list-aliases ls              # Find aliases containing 'ls'
    my-list-aliases --platform      # Show only platform-specific aliases
    my-list-aliases "^cd"           # Show aliases starting with 'cd'

ALIAS SOURCES:
    - Base aliases: Cross-platform defaults
    - Platform aliases: OS-specific overrides and additions
    - Local aliases: Personal customizations (~/.aliases.local)

EOF
        return 0
    fi
    
    echo "Available Aliases"
    echo "================="
    echo ""
    
    local temp_file
    temp_file=$(mktemp)
    
    # Function to extract and format aliases from a file
    extract_aliases() {
        local file="$1"
        local section="$2"
        
        if [[ ! -f "$file" ]]; then
            return
        fi
        
        echo "# $section"
        echo ""
        
        # Get all alias lines with their context
        local current_comment=""
        while IFS= read -r line; do
            # Skip empty lines and section headers
            if [[ -z "$line" || "$line" =~ ^[[:space:]]*$ ]]; then
                continue
            fi
            
            # Capture comments (but skip section dividers)
            if [[ "$line" =~ ^[[:space:]]*#[[:space:]]* ]]; then
                local clean_comment="${line#*#}"
                clean_comment="${clean_comment## }"
                
                # Skip section dividers and shellcheck
                if [[ ! "$clean_comment" =~ ^=+ ]] && [[ ! "$clean_comment" =~ shellcheck ]]; then
                    if [[ ${#clean_comment} -gt 3 ]]; then
                        current_comment="$clean_comment"
                    fi
                fi
                continue
            fi
            
            # Process alias definitions
            if [[ "$line" =~ ^[[:space:]]*alias[[:space:]]+([^=]+)=(.*)$ ]]; then
                local alias_name="${BASH_REMATCH[1]}"
                local alias_def="${BASH_REMATCH[2]}"
                
                # Clean up alias name and definition
                alias_name="${alias_name// /}"
                alias_def="${alias_def#\'}"
                alias_def="${alias_def%\'}"
                alias_def="${alias_def#\"}"
                alias_def="${alias_def%\"}"
                
                # Truncate long definitions
                if [[ ${#alias_def} -gt 50 ]]; then
                    alias_def="${alias_def:0:47}..."
                fi
                
                # Use comment if available, otherwise show definition
                if [[ -n "$current_comment" ]]; then
                    printf "  %-18s %s\n" "$alias_name" "$current_comment"
                    current_comment=""
                else
                    printf "  %-18s %s\n" "$alias_name" "$alias_def"
                fi
            fi
            
            # Process function definitions
            if [[ "$line" =~ ^[[:space:]]*([a-zA-Z_][a-zA-Z0-9_]*)[[:space:]]*\(\) ]]; then
                local func_name="${BASH_REMATCH[1]}()"
                
                if [[ -n "$current_comment" ]]; then
                    printf "  %-18s %s\n" "$func_name" "$current_comment"
                    current_comment=""
                else
                    printf "  %-18s %s\n" "$func_name" "Function"
                fi
            fi
            
            # Reset comment on non-comment lines that aren't aliases/functions
            if [[ ! "$line" =~ ^[[:space:]]*# ]] && [[ ! "$line" =~ ^[[:space:]]*alias ]] && [[ ! "$line" =~ \(\) ]]; then
                current_comment=""
            fi
            
        done < "$file"
        
        echo ""
    }
    
    # Base aliases  
    if [[ "$show_platform" != true ]]; then
        extract_aliases "$DOTFILESLOC/base/.aliases" "Base Aliases (Cross-platform)" >> "$temp_file"
    fi
    
    # Platform-specific aliases
    if [[ -n "$OS" && -f "$DOTFILESLOC/platforms/$OS/.aliases" ]]; then
        extract_aliases "$DOTFILESLOC/platforms/$OS/.aliases" "Platform Aliases ($OS)" >> "$temp_file"
    fi
    
    # Local aliases
    if [[ "$show_platform" != true && -f ~/.aliases.local ]]; then
        extract_aliases ~/.aliases.local "Local Aliases (Personal)" >> "$temp_file"
    fi
    
    # Apply pattern filter and display
    if [[ -n "$pattern" ]]; then
        if grep -i "$pattern" "$temp_file"; then
            :
        else
            echo "No aliases found matching pattern: $pattern"
        fi
    else
        cat "$temp_file"
    fi
    
    rm -f "$temp_file"
    
    echo ""
    echo "USAGE TIPS:"
    echo "- Use 'my-list-functions' to see available my- scripts"
    echo "- Use 'alias <name>' to see the full definition of a specific alias"
    echo "- Use 'type <name>' to see if something is an alias, function, or command"
}

# Execute if called directly (not sourced)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    my_list_aliases "$@"
fi