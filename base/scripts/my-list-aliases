#!/bin/bash
# Function: my-list-aliases
# Purpose: List all available aliases with descriptions and sources
# Usage: my-list-aliases [--help] [--platform] [pattern]
# Platform: All
# Dependencies: grep, sort

my_list_aliases() {
    local show_help=false
    local show_platform=false
    local pattern=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help=true
                shift
                ;;
            -p|--platform)
                show_platform=true
                shift
                ;;
            *)
                pattern="$1"
                shift
                ;;
        esac
    done
    
    if [[ "$show_help" == true ]]; then
        cat << EOF
Usage: my-list-aliases [OPTIONS] [PATTERN]

List all available aliases with descriptions and sources.

OPTIONS:
    -h, --help      Show this help message
    -p, --platform  Show only platform-specific aliases
    PATTERN         Filter aliases matching pattern (grep-style)

EXAMPLES:
    my-list-aliases                 # List all aliases
    my-list-aliases ls              # Find aliases containing 'ls'
    my-list-aliases --platform      # Show only platform-specific aliases
    my-list-aliases "^cd"           # Show aliases starting with 'cd'

ALIAS SOURCES:
    - Base aliases: Cross-platform defaults
    - Platform aliases: OS-specific overrides and additions
    - Local aliases: Personal customizations (~/.aliases.local)

EOF
        return 0
    fi
    
    # Color definitions
    local RED='\033[0;31m'
    local GREEN='\033[0;32m'
    local YELLOW='\033[1;33m'
    local BLUE='\033[0;34m'
    local MAGENTA='\033[0;35m'
    local CYAN='\033[0;36m'
    local WHITE='\033[1;37m'
    local GRAY='\033[0;37m'
    local NC='\033[0m' # No Color
    
    echo -e "${WHITE}Available Aliases${NC}"
    echo -e "${WHITE}=================${NC}"
    echo ""
    
    local temp_file
    temp_file=$(mktemp)
    
    # Function to extract and format aliases from a file
    extract_aliases() {
        local file="$1"
        local section="$2"
        
        if [[ ! -f "$file" ]]; then
            return
        fi
        
        echo -e "${CYAN}# $section${NC}"
        echo ""
        
        # Collect all aliases and functions first
        local aliases=()
        local current_comment=""
        
        while IFS= read -r line; do
            # Skip empty lines and section headers
            if [[ -z "$line" || "$line" =~ ^[[:space:]]*$ ]]; then
                continue
            fi
            
            # Capture comments (but skip section dividers)
            if [[ "$line" =~ ^[[:space:]]*#[[:space:]]* ]]; then
                local clean_comment="${line#*#}"
                clean_comment="${clean_comment## }"
                
                # Skip section dividers and shellcheck
                if [[ ! "$clean_comment" =~ ^=+ ]] && [[ ! "$clean_comment" =~ shellcheck ]]; then
                    if [[ ${#clean_comment} -gt 3 ]]; then
                        current_comment="$clean_comment"
                    fi
                fi
                continue
            fi
            
            # Process alias definitions
            if [[ "$line" =~ ^[[:space:]]*alias[[:space:]]+([^=]+)=(.*)$ ]]; then
                local alias_name="${BASH_REMATCH[1]}"
                local alias_def="${BASH_REMATCH[2]}"
                
                # Clean up alias name and definition
                alias_name="${alias_name// /}"
                alias_def="${alias_def#\'}"
                alias_def="${alias_def%\'}"
                alias_def="${alias_def#\"}"
                alias_def="${alias_def%\"}"
                
                # Truncate long definitions
                if [[ ${#alias_def} -gt 65 ]]; then
                    alias_def="${alias_def:0:62}..."
                fi
                
                # Use comment if available, otherwise show definition
                if [[ -n "$current_comment" ]]; then
                    aliases+=("$alias_name|$current_comment")
                    current_comment=""
                else
                    aliases+=("$alias_name|$alias_def")
                fi
            fi
            
            # Process function definitions
            if [[ "$line" =~ ^[[:space:]]*([a-zA-Z_][a-zA-Z0-9_]*)[[:space:]]*\(\) ]]; then
                local func_name="${BASH_REMATCH[1]}()"
                
                if [[ -n "$current_comment" ]]; then
                    aliases+=("$func_name|$current_comment")
                    current_comment=""
                else
                    aliases+=("$func_name|Function")
                fi
            fi
            
            # Reset comment on non-comment lines that aren't aliases/functions
            if [[ ! "$line" =~ ^[[:space:]]*# ]] && [[ ! "$line" =~ ^[[:space:]]*alias ]] && [[ ! "$line" =~ \(\) ]]; then
                current_comment=""
            fi
            
        done < "$file"
        
        # Format in 3 columns
        local total=${#aliases[@]}
        if [[ $total -eq 0 ]]; then
            echo ""
            return
        fi
        
        local rows=$(( (total + 2) / 3 ))  # Round up division
        
        for (( row=0; row<rows; row++ )); do
            local col1_idx=$row
            local col2_idx=$((row + rows))
            local col3_idx=$((row + 2 * rows))
            
            local line_output=""
            
            # Column 1
            if [[ $col1_idx -lt $total ]]; then
                local alias_info="${aliases[$col1_idx]}"
                local alias_name="${alias_info%|*}"
                local alias_desc="${alias_info#*|}"
                line_output+=$(printf "  ${GREEN}%-22s${NC} ${GRAY}%s${NC}" "$alias_name" "${alias_desc:0:45}")
            fi
            
            # Column 2
            if [[ $col2_idx -lt $total ]]; then
                local alias_info="${aliases[$col2_idx]}"
                local alias_name="${alias_info%|*}" 
                local alias_desc="${alias_info#*|}"
                line_output+=$(printf "  ${GREEN}%-22s${NC} ${GRAY}%s${NC}" "$alias_name" "${alias_desc:0:45}")
            fi
            
            # Column 3
            if [[ $col3_idx -lt $total ]]; then
                local alias_info="${aliases[$col3_idx]}"
                local alias_name="${alias_info%|*}"
                local alias_desc="${alias_info#*|}"
                line_output+=$(printf "  ${GREEN}%-22s${NC} ${GRAY}%s${NC}" "$alias_name" "${alias_desc:0:45}")
            fi
            
            echo -e "$line_output"
        done
        
        echo ""
    }
    
    # Base aliases  
    if [[ "$show_platform" != true ]]; then
        extract_aliases "$DOTFILESLOC/base/.aliases" "Base Aliases (Cross-platform)" >> "$temp_file"
    fi
    
    # Platform-specific aliases
    if [[ -n "$OS" && -f "$DOTFILESLOC/platforms/$OS/.aliases" ]]; then
        extract_aliases "$DOTFILESLOC/platforms/$OS/.aliases" "Platform Aliases ($OS)" >> "$temp_file"
    fi
    
    # Local aliases
    if [[ "$show_platform" != true && -f ~/.aliases.local ]]; then
        extract_aliases ~/.aliases.local "Local Aliases (Personal)" >> "$temp_file"
    fi
    
    # Apply pattern filter and display
    if [[ -n "$pattern" ]]; then
        if grep -i "$pattern" "$temp_file"; then
            :
        else
            echo "No aliases found matching pattern: $pattern"
        fi
    else
        cat "$temp_file"
    fi
    
    rm -f "$temp_file"
    
    echo ""
    echo -e "${YELLOW}USAGE TIPS:${NC}"
    echo -e "- Use ${GREEN}'my-list-functions'${NC} to see available my- scripts"  
    echo -e "- Use ${GREEN}'alias <name>'${NC} to see the full definition of a specific alias"
    echo -e "- Use ${GREEN}'type <name>'${NC} to see if something is an alias, function, or command"
}

# Execute if called directly (not sourced)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    my_list_aliases "$@"
fi