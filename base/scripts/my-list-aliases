#!/bin/bash
# Function: my-list-aliases
# Purpose: List all available aliases with descriptions and sources
# Usage: my-list-aliases [--help] [--platform] [pattern]
# Platform: All
# Dependencies: grep, sort

my_list_aliases() {
    local show_help=false
    local show_platform=false
    local pattern=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help=true
                shift
                ;;
            -p|--platform)
                show_platform=true
                shift
                ;;
            *)
                pattern="$1"
                shift
                ;;
        esac
    done
    
    if [[ "$show_help" == true ]]; then
        cat << EOF
Usage: my-list-aliases [OPTIONS] [PATTERN]

List all available aliases with descriptions and sources.

OPTIONS:
    -h, --help      Show this help message
    -p, --platform  Show only platform-specific aliases
    PATTERN         Filter aliases matching pattern (grep-style)

EXAMPLES:
    my-list-aliases                 # List all aliases
    my-list-aliases ls              # Find aliases containing 'ls'
    my-list-aliases --platform      # Show only platform-specific aliases
    my-list-aliases "^cd"           # Show aliases starting with 'cd'

ALIAS SOURCES:
    - Base aliases: Cross-platform defaults
    - Platform aliases: OS-specific overrides and additions
    - Local aliases: Personal customizations (~/.aliases.local)

EOF
        return 0
    fi
    
    # Color definitions
    local RED='\033[0;31m'
    local GREEN='\033[0;32m'
    local YELLOW='\033[1;33m'
    local BLUE='\033[0;34m'
    local MAGENTA='\033[0;35m'
    local CYAN='\033[0;36m'
    local WHITE='\033[1;37m'
    local GRAY='\033[0;37m'
    local NC='\033[0m' # No Color
    
    echo -e "${WHITE}Available Aliases${NC}"
    echo -e "${WHITE}=================${NC}"
    echo ""
    
    local temp_file
    temp_file=$(mktemp)
    
    # Function to extract and format aliases from a file
    extract_aliases() {
        local file="$1"
        local section="$2"
        
        if [[ ! -f "$file" ]]; then
            return
        fi
        
        echo -e "${CYAN}# $section${NC}"
        echo -e "${WHITE}$(printf "%-20s %-30s %s" "COMMAND" "EXAMPLE" "DESCRIPTION")${NC}"
        echo -e "${WHITE}$(printf "%-20s %-30s %s" "-------" "-------" "-----------")${NC}"
        
        # Collect aliases and functions separately
        local aliases=()
        local functions=()
        local current_comment=""
        
        while IFS= read -r line; do
            # Skip empty lines and section headers
            if [[ -z "$line" || "$line" =~ ^[[:space:]]*$ ]]; then
                continue
            fi
            
            # Capture comments (but skip section dividers)
            if [[ "$line" =~ ^[[:space:]]*#[[:space:]]* ]]; then
                local clean_comment="${line#*#}"
                clean_comment="${clean_comment## }"
                
                # Skip section dividers and shellcheck
                if [[ ! "$clean_comment" =~ ^=+ ]] && [[ ! "$clean_comment" =~ shellcheck ]]; then
                    if [[ ${#clean_comment} -gt 3 ]]; then
                        current_comment="$clean_comment"
                    fi
                fi
                continue
            fi
            
            # Process alias definitions
            if [[ "$line" =~ ^[[:space:]]*alias[[:space:]]+([^=]+)=(.*)$ ]]; then
                local alias_name="${BASH_REMATCH[1]}"
                local alias_def="${BASH_REMATCH[2]}"
                
                # Clean up alias name and definition
                alias_name="${alias_name// /}"
                alias_def="${alias_def#\'}"
                alias_def="${alias_def%\'}"
                alias_def="${alias_def#\"}"
                alias_def="${alias_def%\"}"
                
                # Create example usage and description
                local example="$alias_name"
                local description=""
                
                if [[ -n "$current_comment" ]]; then
                    description="$current_comment"
                    current_comment=""
                else
                    description="$alias_def"
                fi
                
                # Truncate long descriptions
                if [[ ${#description} -gt 40 ]]; then
                    description="${description:0:37}..."
                fi
                
                aliases+=("$alias_name|$example|$description")
            fi
            
            # Process function definitions
            if [[ "$line" =~ ^[[:space:]]*([a-zA-Z_][a-zA-Z0-9_]*)[[:space:]]*\(\) ]]; then
                local func_name="${BASH_REMATCH[1]}"
                local example="$func_name"
                local description=""
                
                if [[ -n "$current_comment" ]]; then
                    description="$current_comment"
                    current_comment=""
                else
                    description="Function"
                fi
                
                functions+=("$func_name|$example|$description")
            fi
            
            # Reset comment on non-comment lines that aren't aliases/functions
            if [[ ! "$line" =~ ^[[:space:]]*# ]] && [[ ! "$line" =~ ^[[:space:]]*alias ]] && [[ ! "$line" =~ \(\) ]]; then
                current_comment=""
            fi
            
        done < "$file"
        
        # Sort aliases and functions separately
        if [[ ${#aliases[@]} -gt 0 ]]; then
            IFS=$'\n' aliases=($(sort <<<"${aliases[*]}"))
            for alias_info in "${aliases[@]}"; do
                local cmd="${alias_info%%|*}"
                local temp="${alias_info#*|}"
                local example="${temp%%|*}"
                local desc="${temp#*|}"
                
                printf "${GREEN}%-20s${NC} ${YELLOW}%-30s${NC} ${GRAY}%s${NC}\n" "$cmd" "$example" "$desc"
            done
        fi
        
        # Add functions at the bottom if any exist
        if [[ ${#functions[@]} -gt 0 ]]; then
            if [[ ${#aliases[@]} -gt 0 ]]; then
                echo ""
            fi
            IFS=$'\n' functions=($(sort <<<"${functions[*]}"))
            for func_info in "${functions[@]}"; do
                local cmd="${func_info%%|*}"
                local temp="${func_info#*|}"
                local example="${temp%%|*}"
                local desc="${temp#*|}"
                
                printf "${MAGENTA}%-20s${NC} ${YELLOW}%-30s${NC} ${GRAY}%s${NC}\n" "$cmd" "$example" "$desc"
            done
        fi
        
        echo ""
    }
    
    # Base aliases  
    if [[ "$show_platform" != true ]]; then
        extract_aliases "$DOTFILESLOC/base/.aliases" "Base Aliases (Cross-platform)" >> "$temp_file"
    fi
    
    # Platform-specific aliases
    if [[ -n "$OS" && -f "$DOTFILESLOC/platforms/$OS/.aliases" ]]; then
        extract_aliases "$DOTFILESLOC/platforms/$OS/.aliases" "Platform Aliases ($OS)" >> "$temp_file"
    fi
    
    # Local aliases
    if [[ "$show_platform" != true && -f ~/.aliases.local ]]; then
        extract_aliases ~/.aliases.local "Local Aliases (Personal)" >> "$temp_file"
    fi
    
    # Add my- scripts section
    echo -e "${CYAN}# My- Scripts (Functions)${NC}" >> "$temp_file"
    echo -e "${WHITE}$(printf "%-20s %-30s %s" "COMMAND" "EXAMPLE" "DESCRIPTION")${NC}" >> "$temp_file"
    echo -e "${WHITE}$(printf "%-20s %-30s %s" "-------" "-------" "-----------")${NC}" >> "$temp_file"
    
    # Extract script info from base scripts
    local script_functions=()
    if [[ -d "$DOTFILESLOC/base/scripts" ]]; then
        for script in "$DOTFILESLOC/base/scripts"/my-*; do
            if [[ -f "$script" && -x "$script" ]]; then
                local script_name=$(basename "$script")
                local purpose=$(grep "^# Purpose:" "$script" 2>/dev/null | head -1 | sed 's/^# Purpose: *//')
                local usage=$(grep "^# Usage:" "$script" 2>/dev/null | head -1 | sed 's/^# Usage: *//')
                local example=$(grep "^# Example:" "$script" 2>/dev/null | head -1 | sed 's/^# Example: *//')
                
                # Use example if available, otherwise usage, otherwise just command name
                local display_example="$script_name"
                if [[ -n "$example" ]]; then
                    display_example="$example"
                elif [[ -n "$usage" ]]; then
                    display_example="$usage"
                fi
                
                # Use purpose if available
                local description="Script function"
                if [[ -n "$purpose" ]]; then
                    description="$purpose"
                    # Truncate long descriptions
                    if [[ ${#description} -gt 40 ]]; then
                        description="${description:0:37}..."
                    fi
                fi
                
                script_functions+=("$script_name|$display_example|$description")
            fi
        done
    fi
    
    # Add platform-specific scripts if available
    if [[ -n "$OS" && -d "$DOTFILESLOC/platforms/$OS/scripts" ]]; then
        for script in "$DOTFILESLOC/platforms/$OS/scripts"/my-*; do
            if [[ -f "$script" && -x "$script" ]]; then
                local script_name=$(basename "$script")
                local purpose=$(grep "^# Purpose:" "$script" 2>/dev/null | head -1 | sed 's/^# Purpose: *//')
                local usage=$(grep "^# Usage:" "$script" 2>/dev/null | head -1 | sed 's/^# Usage: *//')
                local example=$(grep "^# Example:" "$script" 2>/dev/null | head -1 | sed 's/^# Example: *//')
                
                # Use example if available, otherwise usage, otherwise just command name
                local display_example="$script_name"
                if [[ -n "$example" ]]; then
                    display_example="$example"
                elif [[ -n "$usage" ]]; then
                    display_example="$usage"
                fi
                
                # Use purpose if available
                local description="Platform script"
                if [[ -n "$purpose" ]]; then
                    description="$purpose"
                    # Truncate long descriptions
                    if [[ ${#description} -gt 40 ]]; then
                        description="${description:0:37}..."
                    fi
                fi
                
                script_functions+=("$script_name|$display_example|$description")
            fi
        done
    fi
    
    # Sort and display script functions
    if [[ ${#script_functions[@]} -gt 0 ]]; then
        while IFS= read -r func_info; do
            local cmd="${func_info%%|*}"
            local temp="${func_info#*|}"
            local example="${temp%%|*}"
            local desc="${temp#*|}"
            
            printf "${MAGENTA}%-20s${NC} ${YELLOW}%-30s${NC} ${GRAY}%s${NC}\n" "$cmd" "$example" "$desc" >> "$temp_file"
        done < <(printf '%s\n' "${script_functions[@]}" | sort)
    fi
    
    echo "" >> "$temp_file"
    
    # Apply pattern filter and display
    if [[ -n "$pattern" ]]; then
        if grep -i "$pattern" "$temp_file"; then
            :
        else
            echo "No aliases found matching pattern: $pattern"
        fi
    else
        cat "$temp_file"
    fi
    
    rm -f "$temp_file"
    
    echo ""
    echo -e "${YELLOW}USAGE TIPS:${NC}"
    echo -e "- Use ${GREEN}'my-list-functions'${NC} to see available my- scripts"  
    echo -e "- Use ${GREEN}'alias <name>'${NC} to see the full definition of a specific alias"
    echo -e "- Use ${GREEN}'type <name>'${NC} to see if something is an alias, function, or command"
}

# Execute if called directly (not sourced)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    my_list_aliases "$@"
fi